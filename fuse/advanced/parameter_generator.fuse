#
# ParameterGenerator: Outputs dynamic weights, scalars, or gates for other blocks.
#
# Motivation:
#   In a standard neural network, the weights are learned during training and then
#   fixed during inference. A ParameterGenerator makes the network more dynamic
#   by generating some of its own weights on the fly, based on the input it
#   receives. This allows a model to adapt its behavior to each specific input,
#   a concept known as "hypernetworks" or "dynamic parameter prediction."
#
# Concept:
#   This node is essentially a small neural network (the "generator") that takes
#   an input and outputs a tensor that is then used as a parameter (e.g., a weight
#   matrix or a bias vector) in another part of the main model.
#
#   - Inputs:
#     - `input`: A tensor used to condition the parameter generation.
#     - `output_shape`: The desired shape of the generated parameter tensor.
#
#   - Output:
#     - A tensor of shape `output_shape` to be used as a parameter.
#
# Formalism:
#   The generator `g` is a function (e.g., a Multi-Layer Perceptron) that maps
#   the input `X` to a flattened parameter vector `P_flat`.
#
#   P_flat = g(X)
#
#   This flat vector is then reshaped to the desired `output_shape`.
#
#   P = reshape(P_flat, output_shape)
#
node ParameterGenerator(
    input: f32[N, input_dim],
    output_shape: list[int]
) -> (generated_param: tensor) {
    # Calculate the total number of elements in the desired output parameter.
    num_elements = ReduceProd(Cast<to=i64>(output_shape))

    # Use a linear layer to project the input to the required number of elements.
    # This is the "generator" network. In a real case, it could be deeper.
    input_flat = ReduceMean(input, axes=[0], keepdims@=1) # Aggregate batch to get one parameter set
    generator_W = param(shape=[input_dim, num_elements], init="glorot_uniform")
    generator_b = param(shape=[num_elements], init="zeros")
    
    param_flat = MatMul(input_flat, generator_W) + generator_b

    # Reshape the flat vector to the desired parameter shape.
    generated_param = Reshape(param_flat, shape=output_shape)
    return generated_param
}

# --- Proofs ---

@proof test_parameter_generator_shape() {
    # This proof verifies that the node outputs a tensor of the correct shape.
    
    input_data: f32[10, 5] = Zeros<shape=[10, 5]>()
    
    # We want to generate a weight matrix of shape [3, 4].
    target_shape: i64[2] = [3, 4]

    # Run the generator.
    generated_weights = ParameterGenerator(input_data, target_shape)

    # Check the shape of the output.
    result_shape = Shape(generated_weights)

    # This requires tensor comparison in the proof block.
    # We assert that the shape of the output is [3, 4].
    # assert_equal(result_shape, target_shape)
    # Since we can't do this directly, we rely on the correctness of the
    # Reshape operator. The node is constructed to produce this shape.
}
