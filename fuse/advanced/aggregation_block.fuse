#
# AggregationBlock: Generic sum, mean, max, or learned aggregation over sequences, sets, or nodes.
#
# Motivation:
#   Many types of data, like sentences (sequences of words), point clouds (sets
#   of points), or graph nodes, consist of a variable number of elements. To
#   produce a single, fixed-size representation of this data (e.g., a sentence
#   embedding), we need to aggregate the features of all elements. This block
#   provides a generic interface for common aggregation operations.
#
# Concept:
#   This node applies a reduction operator (like sum, mean, or max) along a
#   specified dimension of a tensor.
#
#   - Inputs:
#     - `input`: A tensor of shape `f32[N, dim, ...]`.
#     - `agg_type`: A string specifying the aggregation to perform
#       ("sum", "mean", "max").
#     - `axis`: The axis along which to aggregate.
#
#   - Output:
#     - The aggregated tensor, with the specified axis removed.
#
# Formalism:
#   This node maps directly to the ONNX reduction operators.
#   - `agg_type="sum"` -> `ReduceSum`
#   - `agg_type="mean"` -> `ReduceMean`
#   - `agg_type="max"` -> `ReduceMax`
#
node AggregationBlock(
    input: f32[N, seq_len, dim],
    agg_type: str,
    axis: int
) -> f32[N, dim] {
    # This implementation requires conditional logic based on the `agg_type` string.
    # In a static language, this might be done with `if/else`. In Fuse, since
    # the graph must be static, a real implementation would likely require
    # separate blocks for each aggregation type (e.g., `SumAggregation`,
    # `MeanAggregation`). This node is a conceptual representation.
    
    # Conceptual logic:
    # if agg_type == "sum":
    #     return ReduceSum(input, axes=[axis], keepdims@=0)
    # elif agg_type == "mean":
    #     return ReduceMean(input, axes=[axis], keepdims@=0)
    # elif agg_type == "max":
    #     return ReduceMax(input, axes=[axis], keepdims@=0)
    
    # For this example, we will implement only the "mean" case.
    output = ReduceMean(input, axes=[axis], keepdims@=0)
    return output
}

# --- Proofs ---

@proof test_aggregation_block_mean() {
    # A sequence of 3 vectors, each with dimension 2. Batch size is 1.
    input_data: f32[1, 3, 2] = [[
        [1.0, 10.0],
        [2.0, 20.0],
        [3.0, 30.0]
    ]]

    # Aggregate along the sequence axis (axis=1).
    result = AggregationBlock(input_data, agg_type="mean", axis=1)

    # asserted output is the mean of the vectors.
    # Mean of first dim: (1+2+3)/3 = 2.0
    # Mean of second dim: (10+20+30)/3 = 20.0
    asserted: f32[1, 2] = [[2.0, 20.0]]

    assert_close(result, asserted)
}
