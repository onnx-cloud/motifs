# Fuse EBNF Grammar for ONNX

This file is generated by `fuse` — do not edit by hand.

```fuse
// -----
// Start
// -----
start: file
file: (meta | decl | COMMENT)*

// -----
// Metadata / module
// -----
meta: meta_fuse | meta_opset | meta_module | meta_kv | meta_id | meta_training

meta_training: "@training" "{" training_kv_list? "}"

training_kv_list: training_kv ("," training_kv)*
training_kv: IDENT ":" "{" (kwarg ("," kwarg)*)? "}" | kwarg

meta_fuse: "@fuse" VERSION

VERSION: /\d+(\.\d+){0,2}/
meta_opset: "@opset" IDENT NUMBER
meta_module: "@namespace" IDENT | "@domain" IDENT
meta_kv: "@meta" IDENT "=" value_expr
meta_id: "@id" STRING

// -----
// Top-level declarations
// -----
decl: import_decl | export_decl | test_node_decl | golden_decl | decorated_node | node_decl | model_decl | param_decl | const_decl | type_alias_decl | train_decl | frozen_decl

train_decl: "@train" param_decl
frozen_decl: "@frozen" (param_decl | const_decl)


annotation: "@quantize" quantize_args    -> quantize_annot
          | "@dequantize" dequantize_args? -> dequantize_annot
          | "@proof"                         -> proof_annot
          | "@golden" golden_args? -> golden_annot

golden_args: "(" (kwarg ("," kwarg)*)? ")"

decorated_node: annotation* node_decl

quantize_args: "(" STRING ("," kwarg)* ")"
dequantize_args: "(" (kwarg ("," kwarg)*)? ")"

type_alias_decl: "type" IDENT "=" type_expr

import_decl: "@import" IDENT ["@" NUMBER] ["as" IDENT] ["from" STRING] import_variants?
import_variants: "{" variant_decl* "}"
variant_decl: "@variant" IDENT "file" "=" STRING variant_opt_default? variant_opt_keep_external?
variant_opt_default: "default"
variant_opt_keep_external: "@keep_external"

// External data loader syntax used for large constants
imported_tensors: "@import" "(" STRING ("," kwarg)* ")"

// Extend value expressions to allow external load forms
value_expr: literal | list_lit | imported_tensors

node_decl: ("node" | "block")? IDENT generic? "(" param_list? ")" ret_annot? node
test_node_decl: "@proof" node_decl
golden_decl: "@golden" node_decl
model_decl: ("model" | "graph") IDENT "(" param_list? ")" ret_annot? model.
export_decl: "export" IDENT "(" param_list? ")" ret_annot? node

ret_annot: "->" (type_expr | "(" ret_item ("," ret_item)* ")") meta_ann*

ret_item: IDENT ":" type_expr | type_expr

param_list: param ("," param)*
param: IDENT param_type? param_default?
param_type: ":" type_expr meta_ann*
param_default: "=" (value_expr | expr)
param_decl: ("param" | "weight") IDENT ":" type_expr param_default?
const_decl: "const" IDENT ":" type_expr "=" value_expr

meta_ann: "@meta" IDENT "=" value_expr

// -----
// Blocks & statements
// -----

node: "{" (stmt | expr | COMMENT)* "}"
stmt: let_stmt | assign_stmt | assert_stmt | doc_stmt | annot_stmt | return_stmt | COMMENT
let_stmt: (IDENT | ident_tuple) "=" expr

# tuple-like LHS without surrounding brackets: `a, b = ...`
ident_tuple: IDENT ("," IDENT)+
assign_stmt: IDENT ":" type_expr "=" expr
# Support both `assert <expr>` and `assert <expr> == <expr>` 
assert_stmt: ("assert" | "expect") expr ["==" expr]
doc_stmt: "@doc" STRING
annot_stmt: "@" IDENT "(" value_expr ")"
# Allow `return a, b` (tuple return) — accepted by tests/examples.
return_stmt: "return" expr ("," expr)*

// -----
// Expressions
// -----
?expr: if_expr | as_expr | infix
as_expr: infix "as" (type_expr | scalar)
infix: primary (operator primary)*
primary: atom subscript*
# Support inline arrow/lambda expressions used in terse examples: `(a, b) => expr`
# Allow parenthesized tuples/expressions (e.g., `(true, Add(...))`) and inline lambdas
atom: call | cast_expr | ident_list | list_lit | literal | IDENT | paren_expr | lambda_expr
subscript: "[" subscript_inner "]"
subscript_inner: slice_expr | expr ("," expr)*
slice_expr: expr? ":" expr?
call: IDENT generic? "(" args? ")"
cast_expr: "<" type_expr ">" "(" expr ")"
args: arg ("," arg)*
arg: kwarg | attribute | posarg | star_arg
kwarg: IDENT ("=" expr | ":" "=" expr | ":" expr)
attribute: IDENT "@" "=" value_expr
star_arg: "*" expr
posarg: expr

generic: "<" (kwarg | decl_item | scalar) ("," (kwarg | decl_item | scalar))* ">"

decl_item: IDENT ":" type_expr

OP: "+" | "-" | "*" | "/" | "@" | "⊕" | "??"
operator: OP
if_expr: "static" "if" expr node ["else" node]
    | "if" expr node ["else" node]

// -----
// Types
// -----
# Supported type forms (angle-scalar and shorthand). 
# Examples: `f32[2,3]` or `f32[2,3]` or `MyType[3]`.
type_expr: angle_scalar | array_scalar | scalar | ident_array | IDENT
# Allow both plain-scalar and angle-scalar shorthand to be followed by
# dimensions (e.g. `f32[3]` and `f32[2,2]`).
array_scalar: (scalar | angle_scalar) "[" dims "]"
ident_array: IDENT "[" dims "]"
angle_scalar: "<" scalar ">"
dims: dim ("," dim)*
dim: INT | IDENT | "_" | ELLIPSIS | ":" | dim_expr

dim_expr: dim_term (ADDOP dim_term)*
?dim_term: INT | IDENT

ADDOP: "+" | "-" | "//" | "*"

ELLIPSIS: "..."

SCALAR: "f32" | "f64" | "i64" | "i32" | "i16" | "i8"
    | "u64" | "u32" | "u16" | "u8" | "bool"
    | "bf16" | "f16" | "complex64" | "complex128"
scalar: SCALAR

// -----
// Literals
// -----
ident_list: "[" IDENT ("," IDENT)* "]"
list_lit: "[" [expr ("," expr)*] "]"
# Allow nested list literals as values (e.g., [[1.0, 2.0]])
literal: NUMBER | STRING | BOOLEAN | list_lit
NUMBER: /[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?/
STRING: /"([^"\\]|\\.)*"/
BOOLEAN: "true" | "false"

// -----

// -----
// Lambda / inline functions
// -----
lambda_expr: "(" lambda_args? ")" "=>" expr
lambda_args: IDENT ("," IDENT)*

# Parenthesized expressions and expression tuples (e.g., `(true, Add(...))`)
paren_expr: "(" expr ("," expr)* ")"

// -----
// Identifiers
// -----
IDENT: /[A-Za-z_][A-Za-z0-9_.]*/
INT: /\d+/

COMMENT: /#[^\n]*/

%ignore " "
%ignore "\t"
%ignore /(\r?\n)+/
%ignore /#[^\n]*/
# Support C/C++-style single-line comments `// ...`
%ignore /\/\/[^\n]*/
```
## Example: examples/golden/demo.fuse

```fuse
# top-level graph in bound to input/output.
# @proof not required unless novel

@fuse 1.2
@opset onnx 18
@fuse 1.2
@domain examples.golden
@id "https://my.fuse.cloud/examples.golden.demo"

const EPS: f32 = 1e-5
weight W0: f32[3,2]
weight b0: f32[2]

graph demo() -> f32[1,2] {
  a: f32[1,3] = [1.0, 2.0, 3.0]
  out = example(a)
  assert out == [6.0, 12.0]
}

node example(x: f32[1,3]) -> f32[1,2] {
  m = x @ W0
  y = m + b0
  Relu(y)
}


@quantize("int8", scale=0.05)
@dequantize()
node q_demo(x: f32[1]) -> f32[1] {
  x
}

node if_demo(x: f32[1], cond: bool) -> f32[1] {
  if cond {
    Mul(x, 2.0)
  } else {
    x
  }
}

@proof node test_if() {
  out = if_demo([3.0], true)
  assert out == [6.0]
}

@proof node test_q() {
  y = q_demo([2.0])
  assert y == [2.0]
}

node loop_sum(n: i64) -> f32 {
  Loop<
    body=(iter, cond, acc) => (true, Add(acc, <f32>(iter))),
    v_initial=[0.0]
  >(n, true)
}

@proof node test_loop() {
  out = loop_sum(5)
  assert out == [10.0]
}

# Language Specification
## 1. Structure

* **Top-level:** `@opset`, `@meta`, `param/weight`, `const`, `import`, `node/block`, `graph/model`, `export`, `@proof`
* **Comments:** `#`, `//`, `/* */`
* **Attributes:** Postfix `@` only, e.g., `keepdims@=0`


## 2. Types & Shapes

* Scalars: `f32`, `f64`, `i64`, `i32`, `bool`
* Tensors: `<scalar>[dim1, dim2,...]`
* Functions declare typed args and return types; dims can be symbolic


## 3. Core Constructs

| Construct      | Mental model        |
| -------------- | ------------------- |
| `graph`        | Executable graph    |
| `node`           | Reusable subgraph   |
| `weight`       | Frozen param        |
| `const`        | Literal             |
| `static if`    | Compile-time branch |
| `if`           | Runtime branch      |
| `Loop`         | Iteration           |
| `assert`       | Runtime invariant   |
| `stride@=2`    | Callsite attr       |
| `name@=value`  | Attr example          |
| `<f32>(x)`     | Cast                |
| `list[tensor]` | Variadic            |


## 4. Directives

| Directive     | Mental model      |
| ------------- | ----------------- |
| `@fuse`       | Lang version      |
| `@opset`      | Target opset      |
| `@domain`  | Symbol ownership  |
| `@id`         | Stable identity   |
| `@meta`       | Annotations       |
| `@doc`        | Human docs        |
| `@proof`      | Executable spec   |
| `@quantize`   | Quantize          |
| `@dequantize` | Restore precision |


## 5. Calling & example Operators

* Binary: `+ - * / @ ⊕` → maps to ONNX (`Add/Sub/Mul/Div/MatMul/Sum`)
* Calls: `Add(x,y)` or infix `x+y`
* Reduce axes: tensors `<i64>[...]`
```
